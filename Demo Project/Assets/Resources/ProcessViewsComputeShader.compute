#pragma kernel CSMain

RWBuffer<float4> _VolumeBuffer : register(u0);
Texture2D _InputTexture : register(t1);
SamplerState sampler_InputTexture : register(s1);
uint _ViewIndex;
uint _BufferWidth;
uint _BufferHeight;
uint _BufferDepth;

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint3 texCoord = id.xyz;
    
    // Convert 3D coordinates to 2D based on view direction
    float2 uv;
    switch (_ViewIndex)
    {
        case 0: // NX
            uv = float2(texCoord.z, texCoord.y) / float2(_BufferWidth, _BufferHeight);
            break;
        case 1: // NY
            uv = float2(texCoord.z, texCoord.x) / float2(_BufferWidth, _BufferHeight);
            break;
        case 2: // NZ
            uv = float2(texCoord.x, texCoord.y) / float2(_BufferWidth, _BufferHeight);
            break;
        case 3: // PX
            uv = float2(_BufferWidth - texCoord.z, _BufferHeight - texCoord.y) / float2(_BufferWidth, _BufferHeight);
            break;
        case 4: // PY
            uv = float2(_BufferWidth - texCoord.z, _BufferHeight - texCoord.x) / float2(_BufferWidth, _BufferHeight);
            break;
        case 5: // PZ
            uv = float2(_BufferWidth - texCoord.x, _BufferHeight - texCoord.y) / float2(_BufferWidth, _BufferHeight);
            break;
        default: 
            uv = float2(texCoord.z, texCoord.y) / float2(_BufferWidth, _BufferHeight);
            break;
    }

    // Sample input texture
    float4 pixelColor = _InputTexture.SampleLevel(sampler_InputTexture, uv, 0);
    
    // Calculate depth
    float viewDepth = 1.0 - pixelColor.a;
    
    // Calculate 3D position based on viewDepth and view direction
    float3 position;
    switch (_ViewIndex)
    {
        case 0: // NX
            position = float3(viewDepth * _BufferWidth, texCoord.y, texCoord.z);
            break;
        case 1: // NY
            position = float3(texCoord.x, viewDepth * _BufferHeight, texCoord.z);
            break;
        case 2: // NZ
            position = float3(texCoord.x, texCoord.y, viewDepth * _BufferDepth);
            break;
        case 3: // PX
            position = float3(viewDepth * _BufferWidth, texCoord.y, texCoord.z);
            break;
        case 4: // PY
            position = float3(texCoord.x, viewDepth * _BufferHeight, texCoord.z);
            break;
        case 5: // PZ
            position = float3(texCoord.x, texCoord.y, viewDepth * _BufferDepth);
            break;
        default: 
            position = float3(viewDepth * _BufferWidth, texCoord.y, texCoord.z);
            break;
    }

    // Calculate 1D index
    uint index = (uint)position.x + (uint)position.y * _BufferWidth + (uint)position.z * _BufferWidth * _BufferHeight;
    
    // Set voxel color and opacity
    float4 existingColor = _VolumeBuffer[index];
    if (existingColor.a == 0.0f)
    {
        _VolumeBuffer[index] = float4(pixelColor.rgb, pixelColor.a);
    }
    else
    {
        float totalAlpha = existingColor.a + pixelColor.a;
        float4 combinedColor = float4(
            (existingColor.r * existingColor.a + pixelColor.r * pixelColor.a) / totalAlpha,
            (existingColor.g * existingColor.a + pixelColor.g * pixelColor.a) / totalAlpha,
            (existingColor.b * existingColor.a + pixelColor.b * pixelColor.a) / totalAlpha,
            totalAlpha
        );
        _VolumeBuffer[index] = combinedColor;
    }
}